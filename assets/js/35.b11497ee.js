(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{317:function(t,e,s){"use strict";s.r(e);var a=s(14),r=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"为什么在react中不推荐直接修改state"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么在react中不推荐直接修改state"}},[t._v("#")]),t._v(" 为什么在react中不推荐直接修改state")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("调试\n如果使用console.log,并且不直接修改state,之前日志中的state的值就不会被新的state变化影响。这样就可以清楚的看到两次渲染之间state的值发生了什么变化。")])]),t._v(" "),e("li",[e("p",[t._v("优化\nReact常见的优化策略依赖于如果之前的props或者state的值和下一次的相同就跳过渲染。如果你从未直接修改state,那么很快就能看到state是否发生了变化。如果prevObj === obj,那么就可以肯定这个对象的内部没有发生改变")])]),t._v(" "),e("li",[e("p",[t._v("需求变更\n有些应用功能在不出现任何修改的情况下会更容易实现，比如实现撤销/恢复、展示修改历史，或是允许用户把表单重置成某个之前的值。这是因为你可以把 state 之前的拷贝保存到内存中，并适时对其进行再次使用。如果一开始就用了直接修改 state 的方式，那么后面要实现这样的功能就会变得非常困难")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);