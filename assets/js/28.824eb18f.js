(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{313:function(t,a,n){"use strict";n.r(a);var s=n(14),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[t._v("#")]),t._v(" 内存泄漏")]),t._v(" "),a("p",[t._v("内存泄漏是指应用程序中的内存不再使用,但是仍然被占用，导致内存消耗逐渐增加，最终可能导致应用性能下降或崩溃")]),t._v(" "),a("ol",[a("li",[t._v("意外的全局变量")]),t._v(" "),a("li",[t._v("闭包")]),t._v(" "),a("li",[t._v("事件监听器: 忘记移除事件监听器可能会导致内存泄漏，因为与监听器相关联的对象永远无法被移除。")]),t._v(" "),a("li",[t._v("对象之间的转换引用")]),t._v(" "),a("li")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function test(){\n    const data = [] // 大量数据；\n    setInterval(() => {\n      //  闭包持有对'data'的引用\n        console.log(data)\n    }, 1000)\n}\n// test 不再使用时，定时器仍然在运行，导致内存泄漏\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);