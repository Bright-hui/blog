(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{309:function(t,s,a){"use strict";a.r(s);var r=a(14),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"路由的两种模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路由的两种模式"}},[t._v("#")]),t._v(" 路由的两种模式")]),t._v(" "),s("p",[t._v("hash模式和history模式都可以实现改变url，不刷新页面。哈希值的变化不会被发送到服务器。")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("hash 模式: 浏览器暴露hasChange方法，在hash改变的时候触发该事件,且改变页面不刷新，在监听事件的回调函数中，执行展示和隐藏不同UI显示功能，从而实现前端路由。")])]),t._v(" "),s("li",[s("p",[t._v("history 模式: HTML5中History API （pushState replaceState）需要注意的是： 刷新页面时，浏览器会向服务器发起请求，请求的是前端路由中对应的URL路径。由于这些路径在服务器中并不存在实际的静态资源，如果没有适当的后端配置，服务器将会返回404错误。为了使 History 模式下的单页面应用正常工作，后端服务器需要配置将所有未知的路径请求都重定向到前端应用的入口 HTML 文件，通常是 index.html。这样一来，前端 JavaScript 能够接管路由，根据当前 URL 展示相应的内容，从而避免了 404 错误，保证了应用的正常运行。")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);