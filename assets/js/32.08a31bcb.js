(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{316:function(n,t,e){"use strict";e.r(t);var o=e(14),s=Object(o.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"hoc-高阶组件模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hoc-高阶组件模式"}},[n._v("#")]),n._v(" HOC（高阶组件模式）")]),n._v(" "),t("p",[t("strong",[n._v("HOC（高阶组件模式） 是一种复用组件逻辑的技术。")])]),n._v(" "),t("ol",[t("li",[n._v("函数包装器：HOC 是一个函数，接受一个组件为参数，并返回新的组件，这个函数负责将所有的逻辑应用于组件。")]),n._v(" "),t("li",[n._v("组件代理： HOC可以通过属性代理的方式，将额外的属性传递给被包装的组件。这样可以增加组件的功能或者自改其行为。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 首先，我们假设有一个基础组件，它只需要一个列表数据来进行渲染\nconst ListComponent = ({ listData }) => (\n  <ul>\n    {listData.map(item => (\n      <li key={item.id}>{item.text}</li>\n    ))}\n  </ul>\n);\n\n// 现在我们创建一个HOC，它负责异步获取数据并将其作为props传递给被包装组件\nfunction withDataFetching(WrappedComponent) {\n  return class DataFetcher extends React.Component {\n    state = {\n      listData: [],\n      loading: true,\n    };\n\n    componentDidMount() {\n      fetch('https://api.example.com/items')\n        .then(response => response.json())\n        .then(data => this.setState({ listData: data, loading: false }));\n    }\n\n    render() {\n      // 属性代理：将额外的loading状态和获取的数据作为props传递给被包装的组件\n      const { loading, listData } = this.state;\n      return (\n        <WrappedComponent \n          {...this.props}\n          loading={loading}\n          listData={listData}\n        />\n      );\n    }\n  }\n}\n\n// 使用HOC包装ListComponent\nconst EnhancedListComponent = withDataFetching(ListComponent);\n\n// 现在EnhancedListComponent不仅拥有原始的渲染列表功能，还具备了异步获取数据和处理loading状态的能力\nReactDOM.render(<EnhancedListComponent />, document.getElementById('root'));\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[n._v("组件复用：通过使用 HOC，我们可以将公共逻辑从组件中提取出来，并将其应用于多个组件中，从而实现代码的复用。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function withAuthorization(Component, allowedRoles) {\n   \n  return class extends React.Component {\n   \n    render() {\n   \n      const currentUserRole = getCurrentUserRole();\n\n      if (allowedRoles.includes(currentUserRole)) {\n   \n        return <Component {\n   ...this.props} />;\n      } else {\n   \n        return null; // 或者显示一个无权限的提示信息\n      }\n    }\n  }\n}\n\nconst MyComponent = () => {\n   \n  return <div>My Component</div>;\n}\n\nconst AuthorizedComponent = withAuthorization(MyComponent, ['admin', 'manager']);\n")])])]),t("ol",{attrs:{start:"4"}},[t("li",[n._v("透明性：HOC 不会修改传入的组件，而是通过组合的方式将额外的功能应用于它。这种透明性使得组件的结构和行为保持一致。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function withLogging(Component) {\n   \n  return class extends React.Component {\n   \n    componentDidMount() {\n   \n      console.log('Component is mounted');\n    }\n\n    componentWillUnmount() {\n   \n      console.log('Component is unmounted');\n    }\n\n    render() {\n   \n      return <Component {\n   ...this.props} />;\n    }\n  }\n}\n\nconst MyComponent = () => {\n   \n  return <div>My Component</div>;\n}\n\nconst MyComponentWithLogging = withLogging(MyComponent);\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);